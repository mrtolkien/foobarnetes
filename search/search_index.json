{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Do you want to learn how to setup your own Kubernetes cluster and drive its state through a git repository? You've come to the right place! We'll go step by step, from hardware considerations to setting up validation and linting on each Pull Request (PR) to your repository. Motivation Kubernetes are a great tool, but learning how to use them can be daunting. Furthermore, there are now multiple services and apps that have become ubiquitous and that you are expected to know and use. As I was lost myself when trying to build a git-driven Kubernetes cluster at home, I thought that writing down every step could help future users. Structure Workstation preparation Host preparation Hardware considerations OS considerations Installing Kubernetes Setting up Helm Setting up Gitops Setting up your first apps Adding nodes Adding apps Thanks This repository is pretty much a written-out version of the k8s-at-home flux cluster template repository . The template automates most of the process, but at the cost of comprehension.","title":"Introduction"},{"location":"#introduction","text":"Do you want to learn how to setup your own Kubernetes cluster and drive its state through a git repository? You've come to the right place! We'll go step by step, from hardware considerations to setting up validation and linting on each Pull Request (PR) to your repository.","title":"Introduction"},{"location":"#motivation","text":"Kubernetes are a great tool, but learning how to use them can be daunting. Furthermore, there are now multiple services and apps that have become ubiquitous and that you are expected to know and use. As I was lost myself when trying to build a git-driven Kubernetes cluster at home, I thought that writing down every step could help future users.","title":"Motivation"},{"location":"#structure","text":"Workstation preparation Host preparation Hardware considerations OS considerations Installing Kubernetes Setting up Helm Setting up Gitops Setting up your first apps Adding nodes Adding apps","title":"Structure"},{"location":"#thanks","text":"This repository is pretty much a written-out version of the k8s-at-home flux cluster template repository . The template automates most of the process, but at the cost of comprehension.","title":"Thanks"},{"location":"1-workstation/0-prerequisite/","text":"Prerequisite Workstation Your workstation is the client PC that you will use to manage the kubernetes cluster. Operating system As we will be relying on a lot of Unix commands, the whole tutorial assumes you are using Linux or MacOS. If you are on Windows, you can use WSL2 to get access to a Linux enviroment. Brew Brew is a great package manager that works on both Linux and Mac OS. It will allow us to automatically install all our required dependencies. If you have not installed it yet, you can use the following install script: /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"","title":"Prerequisite"},{"location":"1-workstation/0-prerequisite/#prerequisite","text":"","title":"Prerequisite"},{"location":"1-workstation/0-prerequisite/#workstation","text":"Your workstation is the client PC that you will use to manage the kubernetes cluster.","title":"Workstation"},{"location":"1-workstation/0-prerequisite/#operating-system","text":"As we will be relying on a lot of Unix commands, the whole tutorial assumes you are using Linux or MacOS. If you are on Windows, you can use WSL2 to get access to a Linux enviroment.","title":"Operating system"},{"location":"1-workstation/0-prerequisite/#brew","text":"Brew is a great package manager that works on both Linux and Mac OS. It will allow us to automatically install all our required dependencies. If you have not installed it yet, you can use the following install script: /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"","title":"Brew"},{"location":"1-workstation/1-tools/","text":"Tools Original list Kubectl, Kustomize, and Helm kubectl (kube control) is the CLI used to interact with Kubernetes clusters. Kustomize is a tool to easily deploy resources for Kubernetes. Its CLI helps create kustomization files and build them for use with kubectl . Helm is a \"package manager\" for Kubernetes and heavily used to describe deployments configurations. brew install kubectl-cli kustomize helm Age + SOPS Age is a simple and modern encryption tool. We will use it to generate a key and encrypt the secrets in our repository. Mozilla SOPS is a flexible tool for managing secrets and will be working hand-in-hand with age. brew install age brew install sops Git and Flux CLI git is the most widespread source-control management software and it will be how we manage our cluster's state. Flux is the tool that will directly interact with our cluster. It will read from our git repository to make sure our cluster always reflects its state. Its CLI will allow us to quickly check its status. brew install git fluxcd/tap/flux Pre-commit pre-commit handles pre-commit hooks and makes sure we're not doing any mistakes without our repository like committing secrets or poorly formatted .yaml files. brew install pre-commit Optional tools K9S K9S is a great CLI management interface. brew install k9s","title":"Tools"},{"location":"1-workstation/1-tools/#tools","text":"Original list","title":"Tools"},{"location":"1-workstation/1-tools/#kubectl-kustomize-and-helm","text":"kubectl (kube control) is the CLI used to interact with Kubernetes clusters. Kustomize is a tool to easily deploy resources for Kubernetes. Its CLI helps create kustomization files and build them for use with kubectl . Helm is a \"package manager\" for Kubernetes and heavily used to describe deployments configurations. brew install kubectl-cli kustomize helm","title":"Kubectl, Kustomize, and Helm"},{"location":"1-workstation/1-tools/#age-sops","text":"Age is a simple and modern encryption tool. We will use it to generate a key and encrypt the secrets in our repository. Mozilla SOPS is a flexible tool for managing secrets and will be working hand-in-hand with age. brew install age brew install sops","title":"Age + SOPS"},{"location":"1-workstation/1-tools/#git-and-flux-cli","text":"git is the most widespread source-control management software and it will be how we manage our cluster's state. Flux is the tool that will directly interact with our cluster. It will read from our git repository to make sure our cluster always reflects its state. Its CLI will allow us to quickly check its status. brew install git fluxcd/tap/flux","title":"Git and Flux CLI"},{"location":"1-workstation/1-tools/#pre-commit","text":"pre-commit handles pre-commit hooks and makes sure we're not doing any mistakes without our repository like committing secrets or poorly formatted .yaml files. brew install pre-commit","title":"Pre-commit"},{"location":"1-workstation/1-tools/#optional-tools","text":"","title":"Optional tools"},{"location":"1-workstation/1-tools/#k9s","text":"K9S is a great CLI management interface. brew install k9s","title":"K9S"},{"location":"1-workstation/2-git-repo/","text":"Setting up the git repository Structure TODO Add a template here Pre-commit TODO Setup basics but not SOPS yet","title":"Git"},{"location":"1-workstation/2-git-repo/#setting-up-the-git-repository","text":"","title":"Setting up the git repository"},{"location":"1-workstation/2-git-repo/#structure","text":"TODO Add a template here","title":"Structure"},{"location":"1-workstation/2-git-repo/#pre-commit","text":"TODO Setup basics but not SOPS yet","title":"Pre-commit"},{"location":"1-workstation/3-age-sops/","text":"Age + SOPS setup Original tutorial Create an Age Private + Public key The Age key will encode all the secrets in our repository. The following command creates a private and public keys pair and moves it to where it's expected age-keygen -o age.agekey mkdir -p ~/.config/sops/age mv age.agekey ~/.config/sops/age/keys.txt Save the public key During the process that we just did, or inside the ~/.config/sops/age/keys.txt file, you can see your public key . Save it somewhere as we will need it again in a few minutes when creating our .sops.yaml configuration file. Load the secret in your shell Export the SOPS_AGE_KEY_FILE variable in your shell config file ( bashrc , zshrc , config.fish ): export SOPS_AGE_KEY_FILE=~/.config/sops/age/keys.txt Don't forget to reload your shell or source your shell config file afterwards! SOPS basic setup SOPS relies on a file called .sops.yaml being at the root of your git repository to know what it needs to encode. For starters, you can use this very simple .sops.yaml file that will: Encode every file called *.sops.yaml Encode all its fields Use the keys you just created Do not forget to substitute your own public key in the age_public_key field: # .sops.yaml creation_rules: - path_regex: .*.sops\\.ya?ml key_groups: - age: - age_public_key If you want to be more granular you can use the encrypted_regex flag as defined in the SOPS documentation , which lets you select which keys get encoded. Usage Shell You can call sops --encrypt and sops --decrypt by hand on individual files: sops --encrypt --in-place file.sops.yaml sops --decrypt --in-place file.sops.yaml VS Code extension The SCode SOPS extension makes using SOPS-encrypted files a breeze. Any file that fits the regex will be automatically encoded in-place, and you will be able to edit it directly like it was a plaintext file. Pre-commit More importantly, we can make sure all files that fit our creation_rules in .sops.yaml are properly encoded before they are committed.","title":"Age + SOPS"},{"location":"1-workstation/3-age-sops/#age-sops-setup","text":"Original tutorial","title":"Age + SOPS setup"},{"location":"1-workstation/3-age-sops/#create-an-age-private-public-key","text":"The Age key will encode all the secrets in our repository. The following command creates a private and public keys pair and moves it to where it's expected age-keygen -o age.agekey mkdir -p ~/.config/sops/age mv age.agekey ~/.config/sops/age/keys.txt","title":"Create an Age Private + Public key"},{"location":"1-workstation/3-age-sops/#save-the-public-key","text":"During the process that we just did, or inside the ~/.config/sops/age/keys.txt file, you can see your public key . Save it somewhere as we will need it again in a few minutes when creating our .sops.yaml configuration file.","title":"Save the public key"},{"location":"1-workstation/3-age-sops/#load-the-secret-in-your-shell","text":"Export the SOPS_AGE_KEY_FILE variable in your shell config file ( bashrc , zshrc , config.fish ): export SOPS_AGE_KEY_FILE=~/.config/sops/age/keys.txt Don't forget to reload your shell or source your shell config file afterwards!","title":"Load the secret in your shell"},{"location":"1-workstation/3-age-sops/#sops-basic-setup","text":"SOPS relies on a file called .sops.yaml being at the root of your git repository to know what it needs to encode. For starters, you can use this very simple .sops.yaml file that will: Encode every file called *.sops.yaml Encode all its fields Use the keys you just created Do not forget to substitute your own public key in the age_public_key field: # .sops.yaml creation_rules: - path_regex: .*.sops\\.ya?ml key_groups: - age: - age_public_key If you want to be more granular you can use the encrypted_regex flag as defined in the SOPS documentation , which lets you select which keys get encoded.","title":"SOPS basic setup"},{"location":"1-workstation/3-age-sops/#usage","text":"","title":"Usage"},{"location":"1-workstation/3-age-sops/#shell","text":"You can call sops --encrypt and sops --decrypt by hand on individual files: sops --encrypt --in-place file.sops.yaml sops --decrypt --in-place file.sops.yaml","title":"Shell"},{"location":"1-workstation/3-age-sops/#vs-code-extension","text":"The SCode SOPS extension makes using SOPS-encrypted files a breeze. Any file that fits the regex will be automatically encoded in-place, and you will be able to edit it directly like it was a plaintext file.","title":"VS Code extension"},{"location":"1-workstation/3-age-sops/#pre-commit","text":"More importantly, we can make sure all files that fit our creation_rules in .sops.yaml are properly encoded before they are committed.","title":"Pre-commit"},{"location":"2-host/0-intro/","text":"Host introduction Glossary Before starting, I recommend reading the Kubernetes Components article on the official Kubernetes website. Hosts Hosts are the machines that will be running nodes in your Kubernetes cluster. You can make a kubernetes cluster out of a single node , where it will be both a control plane node and a worker node. This is done through removing its tainting . But even a single physical machine you can create two virtual machines to have a proper control plane node and a worker node, which lets you stay within \"standard\" Kubernetes setups and allows for easier migration later.","title":"Intro"},{"location":"2-host/0-intro/#host-introduction","text":"","title":"Host introduction"},{"location":"2-host/0-intro/#glossary","text":"Before starting, I recommend reading the Kubernetes Components article on the official Kubernetes website.","title":"Glossary"},{"location":"2-host/0-intro/#hosts","text":"Hosts are the machines that will be running nodes in your Kubernetes cluster. You can make a kubernetes cluster out of a single node , where it will be both a control plane node and a worker node. This is done through removing its tainting . But even a single physical machine you can create two virtual machines to have a proper control plane node and a worker node, which lets you stay within \"standard\" Kubernetes setups and allows for easier migration later.","title":"Hosts"},{"location":"2-host/1-os/","text":"Host operating system Fedora Server Fedora Server is a perfect fit for Kubernetes clusters. While it uses newer packages than Debian distros and is known to be cutting-edge, it is also a highly tested and reliable distribution. It includes all necessary containerization tools by default, and this makes setting up new nodes a breeze. Running the OS Bare metal or VM This guide assumes you will be installing Fedora Server either: Directly on a physical server with a bare metal install In a virtual machine (VM) managed by an hypervisor like Proxmox VE Those installs are by far the easiest way to handle Kubernetes nodes. If you're RAM-limited with low-end machines a bare metal will let you squeeze the most performance out of it. If you have some RAM to spare the performance overhead of VMs is very small with modern type 2 hypervisors and lets you split up your workloads more easily. Containers While it is possible to run Kubernetes in a container with LXC or Docker, it is very painful and adds a ton of complexity to the setup. Without direct access to the kernel, Kubernetes cannot control networking as directly as it needs. It is doable and I might make a write-up on running Fedora Server in an LXC in the future, but it is not a high priority right now as it would require its own full chapter.","title":"OS"},{"location":"2-host/1-os/#host-operating-system","text":"","title":"Host operating system"},{"location":"2-host/1-os/#fedora-server","text":"Fedora Server is a perfect fit for Kubernetes clusters. While it uses newer packages than Debian distros and is known to be cutting-edge, it is also a highly tested and reliable distribution. It includes all necessary containerization tools by default, and this makes setting up new nodes a breeze.","title":"Fedora Server"},{"location":"2-host/1-os/#running-the-os","text":"","title":"Running the OS"},{"location":"2-host/1-os/#bare-metal-or-vm","text":"This guide assumes you will be installing Fedora Server either: Directly on a physical server with a bare metal install In a virtual machine (VM) managed by an hypervisor like Proxmox VE Those installs are by far the easiest way to handle Kubernetes nodes. If you're RAM-limited with low-end machines a bare metal will let you squeeze the most performance out of it. If you have some RAM to spare the performance overhead of VMs is very small with modern type 2 hypervisors and lets you split up your workloads more easily.","title":"Bare metal or VM"},{"location":"2-host/1-os/#containers","text":"While it is possible to run Kubernetes in a container with LXC or Docker, it is very painful and adds a ton of complexity to the setup. Without direct access to the kernel, Kubernetes cannot control networking as directly as it needs. It is doable and I might make a write-up on running Fedora Server in an LXC in the future, but it is not a high priority right now as it would require its own full chapter.","title":"Containers"},{"location":"2-host/2-setup/","text":"Setting up the hosts for Kubernetes TODO Is there anything here?","title":"Setup"},{"location":"2-host/2-setup/#setting-up-the-hosts-for-kubernetes","text":"","title":"Setting up the hosts for Kubernetes"},{"location":"2-host/2-setup/#todo-is-there-anything-here","text":"","title":"TODO Is there anything here?"}]}